using BEPUutilities2.Memory;
using SolverPrototype.Collidables;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Text;

namespace SolverPrototype.CollisionDetection
{
    public interface IContinuations
    {
        void Notify(TypedIndex continuationId);
    }

    /// <summary>
    /// Defines filters that some collision tasks may call when child tasks need to be spawned.
    /// </summary>
    public interface ICollisionSubtaskFilters
    {
        /// <summary>
        /// Checks whether further collision testing should be performed for a given subtask.
        /// </summary>
        /// <typeparam name="TInput">Type of the input used to decide whether to allow contact generation.</typeparam>
        /// <param name="input">Input data to be used to decide whether to allow testing.</param>
        /// <returns>True if testing should proceed, false otherwise.</returns>
        bool AllowCollisionTesting<TInput>(ref TInput input) where TInput : struct;
        /// <summary>
        /// Provides control over subtask generated results before they are reported to the parent task.
        /// </summary>
        /// <typeparam name="TInput">Type of the input used for configuration.</typeparam>
        /// <param name="input">Input used by configuration.</param>
        void Configure<TInput>(ref TInput input) where TInput : struct;
    }

    public abstract class CollisionTask
    {
        /// <summary>
        /// Gets the number of tasks to batch together before executing this task.
        /// </summary>
        public int BatchSize { get; protected set; }
        /// <summary>
        /// Gets the type ids of the specialized subtasks registered by this task.
        /// </summary>
        public int[] Subtasks { get; protected set; }

        //Note that we leave the details of input and output of a task's execution to be undefined.
        //A task can reach into the batcher and create new entries or trigger continuations as required.
        /// <summary>
        /// Executes the task on the given input.
        /// </summary>
        /// <typeparam name="TFilters">Type of the input to interpret for execution.</typeparam>
        /// <param name="input">Input to interpret for execution.</param>
        /// <param name="batcher">Batcher responsible for the invocation.</param>
        public abstract void ExecuteBatch<TFilters>(ref UntypedList batch, ref StreamingBatcher batcher, ref TFilters filters)
            where TFilters : struct, ICollisionSubtaskFilters;

        /// <summary>
        /// Registers the the subtasks that may be generated by this task.
        /// </summary>
        /// <param name="matrix">Matrix to register the relationship in.</param>
        public abstract void RegisterSubtasks(CollisionTypeMatrix matrix);
    }

    public class CollisionTypeMatrix
    {
        int[][] topLevelMatrix;
        int nextIndex;
        internal CollisionTask[] tasks;


        public CollisionTypeMatrix(int initialShapeCount = 9)
        {
            ResizeMatrix(initialShapeCount);
            for (int i = 0; i < topLevelMatrix.Length; ++i)
            {
                for (int j = 0; j < topLevelMatrix[i].Length; ++j)
                {
                    //-1 implies that the type pair is not registered. This is used to catch misuse.
                    topLevelMatrix[i][j] = -1;
                }
            }

        }

        void ResizeMatrix(int newSize)
        {
            Array.Resize(ref topLevelMatrix, newSize);
            for (int i = 0; i < newSize; ++i)
            {
                Array.Resize(ref topLevelMatrix[i], newSize);
            }
        }

        internal int RegisterSubtask(CollisionTask task)
        {
            var index = nextIndex++;
            if (index >= tasks.Length)
                Array.Resize(ref tasks, index + 1);
            tasks[index] = task;
            return index;
        }
        public void Register(int a, int b, CollisionTask pairTester)
        {
            var highestIndex = a > b ? a : b;
            if (highestIndex >= topLevelMatrix.Length)
                ResizeMatrix(highestIndex + 1);
            var index = nextIndex++;
            if (index >= tasks.Length)
                Array.Resize(ref tasks, index + 1);
            tasks[index] = pairTester;
            topLevelMatrix[a][b] = index;
            topLevelMatrix[b][a] = index;

            pairTester.RegisterSubtasks(this);
        }
        public void Register<TShapeA, TShapeB>(CollisionTask pairTester)
            where TShapeA : struct, IShape where TShapeB : struct, IShape
        {
            Register(TypeIds<IShape>.GetId<TShapeA>(), TypeIds<IShape>.GetId<TShapeB>(), pairTester);
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTask(int topLevelTypeA, int topLevelTypeB, out CollisionTask task, out int taskIndex)
        {
            taskIndex = topLevelMatrix[topLevelTypeA][topLevelTypeB];
            task = tasks[taskIndex];
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTask<TShapeA, TShapeB>(out CollisionTask task, out int taskIndex)
            where TShapeA : struct, IShape
            where TShapeB : struct, IShape
        {
            GetTask(TypeIds<IShape>.GetId<TShapeA>(), TypeIds<IShape>.GetId<TShapeB>(), out task, out taskIndex);
        }
    }

    struct RigidPair<TShapeA, TShapeB>
            where TShapeA : struct, IShape where TShapeB : struct, IShape
    {
        public TShapeA A;
        public TShapeB B;
        public BodyPose PoseA;
        public BodyPose PoseB;
    }


    public struct StreamingBatcher
    {
        //The streaming batcher contains batches for pending work submitted by the user.
        //This pending work can be top level pairs like sphere versus sphere, but it may also be subtasks of submitted work.
        //Consider two compound bodies colliding. The pair will decompose into a set of potentially many convex subpairs.
        //Similarly, a hull-hull collision test could spawn many subtasks, but those subtasks may not be of the same type as any top level pair.
        //The implication ist hat th e

        CollisionTypeMatrix typeMatrix;
        BufferPool pool;

        Buffer<UntypedList> batches;

        public StreamingBatcher(BufferPool pool, CollisionTypeMatrix collisionTypeMatrix)
        {
            this.pool = pool;
            typeMatrix = collisionTypeMatrix;
            pool.SpecializeFor<UntypedList>().Take(collisionTypeMatrix.tasks.Length, out batches);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Add<TShapeA, TShapeB, TContinuations, TFilters>(CollisionTask task, int taskIndex, 
            ref TShapeA shapeA, ref TShapeB shapeB, ref BodyPose poseA, ref BodyPose poseB,
            TypedIndex continuationId, ref TContinuations continuations, ref TFilters filters)
            where TShapeA : struct, IShape where TShapeB : struct, IShape
            where TContinuations : struct, IContinuations
            where TFilters : struct, ICollisionSubtaskFilters
        {
            ref var batch = ref batches[taskIndex];
            var byteIndex = batch.Allocate<RigidPair<TShapeA, TShapeB>>(task.BatchSize, pool);
            ref var pairData = ref batch.GetFromBytes<RigidPair<TShapeA, TShapeB>>(byteIndex);
            pairData.A = shapeA;
            pairData.B = shapeB;
            pairData.PoseA = poseA;
            pairData.PoseB = poseB;
            if (batch.Count == task.BatchSize)
            {
                task.ExecuteBatch(ref batch, ref this, ref filters);
            }
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Add<TShapeA, TShapeB, TContinuations, TFilters>(ref TShapeA shapeA, ref TShapeB shapeB, ref BodyPose poseA, ref BodyPose poseB,
             TypedIndex continuationId, ref TContinuations continuations, ref TFilters filters)
             where TShapeA : struct, IShape where TShapeB : struct, IShape
             where TContinuations : struct, IContinuations
             where TFilters : struct, ICollisionSubtaskFilters
        {
            //TODO: It's possible that only retrieving the actual task in the event that it's time to dispatch could save some cycles.
            //That would imply caching the batch sizes and expected first ids, likely alongside the task indices.
            //Value of that is questionable, since all the task-associated indirections are pretty much guaranteed to be cached.
            typeMatrix.GetTask<TShapeA, TShapeB>(out var task, out var taskIndex);
            if (typeof(TShapeA) != typeof(TShapeB))
            {
                //The inputs may need to be reordered to guarantee that the collision tasks are handed data in the proper order.
                if (TypeIds<IShape>.GetId<TShapeA>() == task.ExpectedFirstId)
                {

                }
                else
                {

                }
            }
            else
            {

            }
           
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Flush<TContinuations>(ref TContinuations continuations)
        {

        }
    }
}
