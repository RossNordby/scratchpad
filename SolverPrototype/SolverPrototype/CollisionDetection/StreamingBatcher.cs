using BEPUutilities2.Collections;
using BEPUutilities2.Memory;
using SolverPrototype.Collidables;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Text;

namespace SolverPrototype.CollisionDetection
{
    public interface IContinuations
    {
        void Notify(TypedIndex continuationId);
    }

    /// <summary>
    /// Defines filters that some collision tasks may call when child tasks need to be spawned.
    /// </summary>
    public interface ICollisionSubtaskFilters
    {
        /// <summary>
        /// Checks whether further collision testing should be performed for a given subtask.
        /// </summary>
        /// <typeparam name="TInput">Type of the input used to decide whether to allow contact generation.</typeparam>
        /// <param name="input">Input data to be used to decide whether to allow testing.</param>
        /// <returns>True if testing should proceed, false otherwise.</returns>
        bool AllowCollisionTesting<TInput>(ref TInput input) where TInput : struct;
        /// <summary>
        /// Provides control over subtask generated results before they are reported to the parent task.
        /// </summary>
        /// <typeparam name="TInput">Type of the input used for configuration.</typeparam>
        /// <param name="input">Input used by configuration.</param>
        void Configure<TInput>(ref TInput input) where TInput : struct;
    }

    public abstract class CollisionTask
    {
        /// <summary>
        /// Gets the number of tasks to batch together before executing this task.
        /// </summary>
        public int BatchSize { get; protected set; }
        /// <summary>
        /// Gets the type ids of the specialized subtasks registered by this task.
        /// </summary>
        public int[] Subtasks { get; protected set; }
        public int ExpectedFirstId { get; protected set; }

        //Note that we leave the details of input and output of a task's execution to be undefined.
        //A task can reach into the batcher and create new entries or trigger continuations as required.
        /// <summary>
        /// Executes the task on the given input.
        /// </summary>
        /// <typeparam name="TFilters">Type of the filters used to influence execution of collision tasks.</typeparam>
        /// <typeparam name="TContinuations">Type of the continuations that can be triggered by the this execution.</typeparam>
        /// <param name="batcher">Batcher responsible for the invocation.</param>
        /// <param name="batch">Batch of pairs to test.</param>
        /// <param name="continuations">Continuations to invoke upon completion of a top level pair.</param>
        /// <param name="filters">Filters to use to influence execution of the collision tasks.</param>
        public abstract void ExecuteBatch<TContinuations, TFilters>(ref UntypedList batch, ref StreamingBatcher batcher, ref TContinuations continuations, ref TFilters filters)
            where TContinuations : struct, IContinuations
            where TFilters : struct, ICollisionSubtaskFilters;

        /// <summary>
        /// Registers the the subtasks that may be generated by this task.
        /// </summary>
        /// <param name="matrix">Matrix to register the relationship in.</param>
        public abstract void RegisterSubtasks(CollisionTypeMatrix matrix);
    }

    public class CollisionTypeMatrix
    {
        int[][] topLevelMatrix;
        int nextIndex;
        internal CollisionTask[] tasks;


        public CollisionTypeMatrix(int initialShapeCount = 9)
        {
            ResizeMatrix(initialShapeCount);
            for (int i = 0; i < topLevelMatrix.Length; ++i)
            {
                for (int j = 0; j < topLevelMatrix[i].Length; ++j)
                {
                    //-1 implies that the type pair is not registered. This is used to catch misuse.
                    topLevelMatrix[i][j] = -1;
                }
            }

        }

        void ResizeMatrix(int newSize)
        {
            Array.Resize(ref topLevelMatrix, newSize);
            for (int i = 0; i < newSize; ++i)
            {
                Array.Resize(ref topLevelMatrix[i], newSize);
            }
        }

        internal int RegisterSubtask(CollisionTask task)
        {
            var index = nextIndex++;
            if (index >= tasks.Length)
                Array.Resize(ref tasks, index + 1);
            tasks[index] = task;
            return index;
        }
        public void Register(int a, int b, CollisionTask pairTester)
        {
            var highestIndex = a > b ? a : b;
            if (highestIndex >= topLevelMatrix.Length)
                ResizeMatrix(highestIndex + 1);
            var index = nextIndex++;
            if (index >= tasks.Length)
                Array.Resize(ref tasks, index + 1);
            tasks[index] = pairTester;
            topLevelMatrix[a][b] = index;
            topLevelMatrix[b][a] = index;

            pairTester.RegisterSubtasks(this);
        }
        public void Register<TShapeA, TShapeB>(CollisionTask pairTester)
            where TShapeA : struct, IShape where TShapeB : struct, IShape
        {
            Register(TypeIds<IShape>.GetId<TShapeA>(), TypeIds<IShape>.GetId<TShapeB>(), pairTester);
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTask(int topLevelTypeA, int topLevelTypeB, out CollisionTask task, out int taskIndex)
        {
            taskIndex = topLevelMatrix[topLevelTypeA][topLevelTypeB];
            task = tasks[taskIndex];
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTask<TShapeA, TShapeB>(out CollisionTask task, out int taskIndex)
            where TShapeA : struct, IShape
            where TShapeB : struct, IShape
        {
            GetTask(TypeIds<IShape>.GetId<TShapeA>(), TypeIds<IShape>.GetId<TShapeB>(), out task, out taskIndex);
        }
    }

    struct RigidPair<TShapeA, TShapeB>
            where TShapeA : struct, IShape where TShapeB : struct, IShape
    {
        public TShapeA A;
        public TShapeB B;
        public BodyPose RelativePose;
        public TypedIndex Continuation;
    }


    public struct StreamingBatcher
    {
        //The streaming batcher contains batches for pending work submitted by the user.
        //This pending work can be top level pairs like sphere versus sphere, but it may also be subtasks of submitted work.
        //Consider two compound bodies colliding. The pair will decompose into a set of potentially many convex subpairs.
        //Similarly, a hull-hull collision test could spawn many subtasks, but those subtasks may not be of the same type as any top level pair.
        //The implication ist hat th e

        CollisionTypeMatrix typeMatrix;
        BufferPool pool;

        struct Batch
        {
            public UntypedList List;
            public int TaskTypeIndex;

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public Batch(BufferPool pool, int byteCount, int taskTypeIndex)
            {
                List = new UntypedList(byteCount, pool);
                TaskTypeIndex = taskTypeIndex;
            }
        }

        QuickList<Batch, Buffer<Batch>> batches;
        //A subset of collision tasks require a place to return information.
        QuickList<Batch, Buffer<Batch>> localContinuations;
        struct TaskIndices
        {
            public int TaskIndex;
            public short ContinuationType;
            public short ContinuationIndex;
        }

        Buffer<TaskIndices> taskTypeToTaskIndices;

        public unsafe StreamingBatcher(BufferPool pool, CollisionTypeMatrix collisionTypeMatrix)
        {
            this.pool = pool;
            typeMatrix = collisionTypeMatrix;
            QuickList<Batch, Buffer<Batch>>.Create(pool.SpecializeFor<Batch>(), collisionTypeMatrix.tasks.Length, out batches);
            QuickList<Batch, Buffer<Batch>>.Create(pool.SpecializeFor<Batch>(), collisionTypeMatrix.tasks.Length, out localContinuations);
            pool.SpecializeFor<TaskIndices>().Take(collisionTypeMatrix.tasks.Length, out taskTypeToTaskIndices);
            Unsafe.InitBlockUnaligned(ref *taskTypeToTaskIndices.Memory, 0xFF, (uint)(Unsafe.SizeOf<TaskIndices>() * collisionTypeMatrix.tasks.Length));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Add<TShapeA, TShapeB, TContinuations, TFilters>(CollisionTask task, int taskIndex,
            ref TShapeA shapeA, ref TShapeB shapeB, ref BodyPose relativePose,
            TypedIndex continuationId, ref TContinuations continuations, ref TFilters filters)
            where TShapeA : struct, IShape where TShapeB : struct, IShape
            where TContinuations : struct, IContinuations
            where TFilters : struct, ICollisionSubtaskFilters
        {
            ref var batch = ref batches[taskIndex];
            ref var pairData = ref batch.List.AllocateUnsafely<RigidPair<TShapeA, TShapeB>>();
            pairData.A = shapeA;
            pairData.B = shapeB;
            pairData.RelativePose = relativePose;
            if (batch.List.Count == task.BatchSize)
            {
                task.ExecuteBatch(ref batch.List, ref this, ref continuations, ref filters);
            }
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Add<TShapeA, TShapeB, TContinuations, TFilters>(ref TShapeA shapeA, ref TShapeB shapeB, ref BodyPose relativePose,
             TypedIndex continuationId, ref TContinuations continuations, ref TFilters filters)
             where TShapeA : struct, IShape where TShapeB : struct, IShape
             where TContinuations : struct, IContinuations
             where TFilters : struct, ICollisionSubtaskFilters
        {
            //TODO: It's possible that only retrieving the actual task in the event that it's time to dispatch could save some cycles.
            //That would imply caching the batch sizes and expected first ids, likely alongside the task indices.
            //Value of that is questionable, since all the task-associated indirections are pretty much guaranteed to be cached.
            typeMatrix.GetTask<TShapeA, TShapeB>(out var task, out var taskTypeIndex);
            ref var taskIndices = ref taskTypeToTaskIndices[taskTypeIndex];
            if (taskIndices.TaskIndex == unchecked((int)0xFFFF_FFFF))
            {
                taskIndices.TaskIndex = batches.Count;
                batches.AllocateUnsafely() = new Batch(pool, task.BatchSize * Unsafe.SizeOf<RigidPair<TShapeA, TShapeB>>(), taskTypeIndex);
            }
            //The type comparison should be a compilation constant.
            if (typeof(TShapeA) != typeof(TShapeB) && TypeIds<IShape>.GetId<TShapeA>() != task.ExpectedFirstId)
            {
                //The inputs need to be reordered to guarantee that the collision tasks are handed data in the proper order.
                Add(task, taskIndices.TaskIndex, ref shapeA, ref shapeB, ref relativePose, continuationId, ref continuations, ref filters);
            }
            else
            {
                Add(task, taskIndices.TaskIndex, ref shapeA, ref shapeB, ref relativePose, continuationId, ref continuations, ref filters);
            }

        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Flush<TContinuations, TFilters>(ref TContinuations continuations, ref TFilters filters)
            where TContinuations : struct, IContinuations
            where TFilters : struct, ICollisionSubtaskFilters
        {
            while (batches.Count > 0)
            {
                //TODO: Each batch execution may create additional work that must then be flushed, so we must restart the loop if batches persist.
                //May be able to do something like position all work generators up front if you can prove a DAG relationship between collision tasks.
                //The type matrix's registration process could help here- we can spend an arbitrarily long time building some form of structure during registration to help us during runtime.
                for (int i = 0; i < batches.Count; ++i)
                {
                    ref var batch = ref batches[i];
                    if (batch.List.Count > 0)
                    {
                        typeMatrix.tasks[batch.TaskTypeIndex].ExecuteBatch(ref batch.List, ref this, ref filters);
                    }
                }
            }
            //TODO: dispose everything here too. 
        }
    }
}
